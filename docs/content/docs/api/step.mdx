---
title: <Step>
description: Groups fields into a logical step for validation and navigation
---

The `Step` component groups `Controller` fields into a logical step. Fields inside a `Step` are automatically registered and validated together.

## Usage

```tsx
import { Step, Controller } from 'rhf-stepper'

<Step>
  {currentStep === 0 && (
    <>
      <Controller name="firstName" render={({ field }) => <input {...field} />} />
      <Controller name="lastName" render={({ field }) => <input {...field} />} />
    </>
  )}
</Step>
```

## Props

| Prop | Type | Description |
|------|------|-------------|
| `children` | `ReactNode` | The step content (controllers and other elements) |

## Always-Mounted Pattern

<Callout type="warn">
`<Step>` components must always be mounted in the tree. Do not conditionally render the `<Step>` itself — only its children.
</Callout>

```tsx
// ✅ Correct — Step is always mounted, children are conditional
<Step>
  {currentStep === 0 && (
    <Controller name="email" render={({ field }) => <input {...field} />} />
  )}
</Step>

// ❌ Wrong — Step is conditionally mounted
{currentStep === 0 && (
  <Step>
    <Controller name="email" render={({ field }) => <input {...field} />} />
  </Step>
)}
```

This is because `Step` registers itself in the step tree when it mounts. If a `Step` is conditionally rendered, it will register/unregister as it mounts/unmounts, breaking the step tree.

## Nesting Steps

Steps can be nested for sub-step grouping:

```tsx
<Step>
  <Step>
    {currentStep === 0 && (
      <Controller name="a" render={({ field }) => <input {...field} />} />
    )}
  </Step>
  <Step>
    {currentStep === 1 && (
      <Controller name="b" render={({ field }) => <input {...field} />} />
    )}
  </Step>
</Step>
```

Nested steps create a tree structure. Navigation functions (`next`/`prev`) traverse this tree by finding the next/previous "leaf parent" — a node whose children are all field names.
